// <auto-generated> This file has been auto generated by EF Core Power Tools. </auto-generated>
#nullable enable

using System.ComponentModel.DataAnnotations.Schema;
using System.Data;
using System.Data.SqlClient;
using System.Linq;
using System.Reflection;
using Microsoft.EntityFrameworkCore.Metadata;

namespace MTGView.Data.EFCore.Contexts;

public partial class MagicthegatheringDbContext : DbContext
{
    public MagicthegatheringDbContext(DbContextOptions<MagicthegatheringDbContext> options)
        : base(options)
    {
    }

    public virtual DbSet<MagicCard> Cards { get; set; } = null!;

    public virtual DbSet<Meta> Metas { get; set; } = null!;
    
    public virtual DbSet<Legality> Legalities { get; set; } = null!;
    
    public virtual DbSet<Ruling> Rulings { get; set; } = null!;
    
    public virtual DbSet<MagicSet> Sets { get; set; } = null!;

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.ApplyConfiguration(new Configurations.CardConfiguration());
        modelBuilder.ApplyConfiguration(new Configurations.MetaConfiguration());
        modelBuilder.ApplyConfiguration(new Configurations.LegalityConfiguration());
        modelBuilder.ApplyConfiguration(new Configurations.RulingConfiguration());
        modelBuilder.ApplyConfiguration(new Configurations.SetConfiguration());

        OnModelCreatingPartial(modelBuilder);
    }

    partial void OnModelCreatingPartial(ModelBuilder modelBuilder);

    public async Task BulkInsertAllAsync<T>(IEnumerable<T> entities, CancellationToken cancellationToken = default)
    {
        var connectionString = Database.GetConnectionString();

        await using var connection = new SqlConnection(connectionString);

        var entityType = typeof(T);

        var destinationTableName = Model.FindEntityType(entityType)?.GetSchemaQualifiedTableName();

        try
        {

            await connection.OpenAsync(cancellationToken);

            using var bulkCopy = new SqlBulkCopy(connection)
            {
                DestinationTableName = destinationTableName
            };

            var properties = Model.FindEntityType(entityType)!.GetProperties();
            
            using var table = new DataTable();

            table.Columns.AddRange(properties.Select(CreateEntityDataColumns).ToArray());

            foreach (var entity in entities)
            {
                var mappedProperties = properties
                    .Select(property => GetPropertyValue(property.PropertyInfo?.GetValue((entity)))).ToArray();

                table.Rows.Add(mappedProperties);
            }
            
            await bulkCopy.WriteToServerAsync(table, cancellationToken);
        }
        finally
        {
            await connection.CloseAsync();
        }
    }

    private static DataColumn CreateEntityDataColumns(IProperty property)
    {
        var propertyType = Type.GetType(property.ClrType.AssemblyQualifiedName!);

        if (propertyType!.IsGenericType && propertyType.GetGenericTypeDefinition() == typeof(Nullable<>))
        {
            propertyType = Nullable.GetUnderlyingType(propertyType);
        }

        return new DataColumn(property.Name, propertyType!)
        {
            AllowDBNull = Nullable.GetUnderlyingType(Type.GetType(property.ClrType.AssemblyQualifiedName)) != null,
        };
    }

    private static object GetPropertyValue(object? o) => o ?? DBNull.Value;

}
